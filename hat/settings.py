"""
Django settings for iaso project.

Generated by 'django-admin startproject' using Django 1.9.7.

For more information on this file, see
https://docs.djangoproject.com/en/1.9/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.9/ref/settings/
"""

import base64
import hashlib
import html
import os
import re
import sys
import urllib.parse
import importlib
from datetime import timedelta
from typing import Any, Dict
from urllib.parse import urlparse

import sentry_sdk
from django.core.exceptions import ImproperlyConfigured
from django.utils.translation import gettext_lazy as _
from requests.exceptions import HTTPError
from sentry_sdk.integrations.django import DjangoIntegration
from sentry_sdk.integrations.logging import ignore_logger

from plugins.wfp.wfp_pkce_generator import generate_pkce

# security settings
CSRF_COOKIE_HTTPONLY = os.environ.get("CSRF_COOKIE_HTTPONLY", "false").lower() == "true"
CSRF_COOKIE_SECURE = os.environ.get("CSRF_COOKIE_SECURE", "false").lower() == "true"
SESSION_COOKIE_SECURE = os.environ.get("SESSION_COOKIE_SECURE", "false").lower() == "true"
ENABLE_CORS = os.environ.get("ENABLE_CORS", "true").lower() == "true"

# This should be the naked domain (no http or https prefix) that is
# hosting Iaso, this is used when sending out emails that need a link
# back to the Iaso application.
#
# This should be the same as the one set on: `/admin/sites/site/1/change/`


DNS_DOMAIN = os.environ.get("DNS_DOMAIN", "localhost:8081")
TESTING = os.environ.get("TESTING", "").lower() == "true"
IN_TESTS = len(sys.argv) > 1 and sys.argv[1] == "test"
PLUGINS = os.environ["PLUGINS"].split(",") if os.environ.get("PLUGINS", "") else []

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get("DEBUG", "").lower() == "true"
USE_S3 = os.getenv("USE_S3") == "true"
# Specifying the `STATIC_URL` means that the assets are available at that URL
#
# Currently WFP is deploying this way, where the assets are put on a
# S3 in a seperate process, and a CDN (Cloudfront) is in front of
# it. So we parse out the hostname, and then set that as the
# CDN_URL, so that Django knows where to fetch them from.
static_url = os.environ.get("STATIC_URL")
if static_url:
    CDN_URL = urlparse(static_url).hostname
else:
    CDN_URL = None

DEV_SERVER = os.environ.get("DEV_SERVER", "").lower() == "true"
ENVIRONMENT = os.environ.get("SENTRY_ENVIRONMENT", "development").lower()
SENTRY_URL = os.environ.get("SENTRY_URL", "")

# There exists plugins using celery for the backend task (but it's not the default task mechanism of Iaso)
# If you have such plugin, you can activate the use of celery by setting this env variable to "true"
USE_CELERY = os.environ.get("USE_CELERY", "")

# It is possible to deactivate password login for the API, the website and the admin using this environment variable
DISABLE_PASSWORD_LOGINS = os.environ.get("DISABLE_PASSWORD_LOGINS", "").lower() == "true"

# env variables allowing to configure the cache used by Iaso. By default, it's using a table in Postgres
# to setup Redis, use django_redis.cache.RedisCache as CACHE_BACKEND and something like "redis://127.0.0.1:6379" as CACHE_LOCATION
CACHE_BACKEND = os.environ.get("CACHE_BACKEND", "django.core.cache.backends.db.DatabaseCache")
CACHE_LOCATION = os.environ.get("CACHE_LOCATION", "django_cache_table")
CACHE_MAX_ENTRIES = os.environ.get("CACHE_MAX_ENTRIES", 300)

ALLOWED_HOSTS = ["*"]

# Tell django to view requests as secure(ssl) that have this header set
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
USE_X_FORWARDED_HOST = True

AWS_STORAGE_BUCKET_NAME = os.environ.get("AWS_STORAGE_BUCKET_NAME", "")

# Default site for django contrib site framework
SITE_ID = 1

# Logging

LOGGING_LEVEL = os.getenv("DJANGO_LOGGING_LEVEL", "INFO")
if TESTING:
    # We don't want to see log output when running tests
    LOGGING_LEVEL = "CRITICAL"

ENKETO = {
    "ENKETO_DEV": os.getenv("ENKETO_DEV"),
    "ENKETO_API_TOKEN": os.getenv("ENKETO_API_TOKEN"),
    "ENKETO_URL": os.getenv("ENKETO_URL"),
    "ENKETO_API_SURVEY_PATH": "/api_v2/survey",
    "ENKETO_API_INSTANCE_PATH": "/api_v2/instance",
}

TEST_RUNNER = "redgreenunittest.django.runner.RedGreenDiscoverRunner"

LOGGING: Dict[str, Any] = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {"default": {"format": "%(levelname)-8s %(asctime)s %(name)s -- %(message)s"}},
    "filters": {"no_static": {"()": "hat.common.log_filter.StaticUrlFilter"}},
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "default",
            # Don't pollute the log output with lots of static url request in development
            "filters": ["no_static"] if DEBUG else None,
        }
    },
    "loggers": {
        "django": {"level": LOGGING_LEVEL},
        "rq": {"level": LOGGING_LEVEL},
        "hat": {"level": LOGGING_LEVEL},
        "iaso": {"level": LOGGING_LEVEL},
        "plugins": {"level": LOGGING_LEVEL},
        "beanstalk_worker": {"level": LOGGING_LEVEL},
        "": {"handlers": ["console"]},
    },
}

if os.getenv("DEBUG_SQL") == "true":
    LOGGING["loggers"]["django.db.backends"] = {"level": "DEBUG"}

# AWS expects python logs to be stored in this folder
AWS_LOG_FOLDER = "/var/app/log"

if os.path.isdir(AWS_LOG_FOLDER):
    if os.access(AWS_LOG_FOLDER, os.W_OK):
        print("Logging to django log")
        LOGGING["handlers"]["file"] = {
            "class": "logging.FileHandler",
            "level": "DEBUG",
            "formatter": "default",
            "filename": os.path.join(AWS_LOG_FOLDER, "django.log"),
        }
        LOGGING["loggers"][""]["handlers"].append("file")
        LOGGING["loggers"]["hat"]["level"] = "DEBUG"
    else:
        print(f"WARNING: we seem to be running on AWS but {AWS_LOG_FOLDER} is not writable, check ebextensions")

# Application definition
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.messages",
    "django.contrib.sessions",
    "django.contrib.staticfiles",
    "django.contrib.gis",
    "django.contrib.postgres",
    "django.contrib.sites",  # needed by contrib-comments
    "allauth",
    "allauth.account",
    "allauth.socialaccount",
    "storages",
]
if ENABLE_CORS:
    INSTALLED_APPS += [
        "corsheaders",
    ]

INSTALLED_APPS += [
    "rest_framework",
    "webpack_loader",
    "django_ltree",
    "hat.sync",
    "hat.api_import",
    "hat.audit",
    "hat.menupermissions",
    "iaso",
    "django_extensions",
    "beanstalk_worker",
    "django_comments",
    "django_filters",
    "drf_yasg",
    "django_json_widget",
    "phonenumber_field",
]

if USE_CELERY:
    INSTALLED_APPS.extend(["django_celery_beat", "django_celery_results"])

# needed because we customize the comment model
# see https://django-contrib-comments.readthedocs.io/en/latest/custom.htm
COMMENTS_APP = "iaso"

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.locale.LocaleMiddleware",
]
if ENABLE_CORS:
    MIDDLEWARE += [
        "corsheaders.middleware.CorsMiddleware",
    ]
MIDDLEWARE += [
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "hat.middleware.ThreadLocalMiddleware",
]
if DEBUG:
    MIDDLEWARE += [
        "querycount.middleware.QueryCountMiddleware",
    ]

ROOT_URLCONF = "hat.urls"

# Allow CORS for all origins but don't transmit the session cookies or other credentials (which is the default)
# see https://github.com/adamchainz/django-cors-headers#cors_allow_credentials-bool

if ENABLE_CORS:
    CORS_ORIGIN_ALLOW_ALL = True
    CORS_ALLOW_ALL_ORIGINS = True  # name used in the new version of django-cors-header, for forward compat
    CORS_ALLOW_CREDENTIALS = False

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [
            "./hat/templates",
            "./django_sql_dashboard_export/templates",
        ],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.template.context_processors.media",
                "django.contrib.messages.context_processors.messages",
                "hat.common.context_processors.appversions",
                "hat.common.context_processors.app_title",
                "hat.common.context_processors.favicon_path",
                "hat.common.context_processors.logo_path",
                "hat.common.context_processors.theme",
            ]
        },
    }
]

WSGI_APPLICATION = "hat.wsgi.application"

# Database

DB_NAME = os.environ.get("RDS_DB_NAME", "iaso")
DB_USERNAME = os.environ.get("RDS_USERNAME", "postgres")
DB_PASSWORD = os.environ.get("RDS_PASSWORD", None)
DB_HOST = os.environ.get("RDS_HOSTNAME", "db")
DB_PORT = os.environ.get("RDS_PORT", 5432)
SNS_NOTIFICATION_TOPIC = os.environ.get("SNS_NOTIFICATION_TOPIC", None)

print(
    "DB_NAME",
    DB_NAME,
)
DATABASES = {
    "default": {
        "ENGINE": "django.contrib.gis.db.backends.postgis",
        "NAME": DB_NAME,
        "USER": DB_USERNAME,
        "PASSWORD": DB_PASSWORD,
        "HOST": DB_HOST,
        "PORT": DB_PORT,
    },
}

"""
Enable the SQL  dashboard Feature
see docs/SQL Dashboard feature.md

[SQL Dashboard feature.md](docs%2FSQL%20Dashboard%20feature.md)
"""

if "test" in sys.argv and DEBUG:
    # For when running unit test
    DATABASES["dashboard"] = DATABASES["default"]

    INSTALLED_APPS.append("django_sql_dashboard")
    INSTALLED_APPS.append("django_sql_dashboard_export")
    # https://django-sql-dashboard.datasette.io/en/stable/setup.html#additional-settings
    DASHBOARD_ENABLE_FULL_EXPORT = True  # allow csv export on /explore
elif os.environ.get("DB_READONLY_USERNAME"):
    DATABASES["dashboard"] = {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": DB_NAME,
        "USER": os.environ.get("DB_READONLY_USERNAME"),
        "PASSWORD": os.environ.get("DB_READONLY_PASSWORD", None),
        "HOST": DB_HOST,
        "PORT": DB_PORT,
        "OPTIONS": {"options": "-c default_transaction_read_only=on -c statement_timeout=10000"},  # type: ignore
    }

    INSTALLED_APPS.append("django_sql_dashboard")
    INSTALLED_APPS.append("django_sql_dashboard_export")
    # https://django-sql-dashboard.datasette.io/en/stable/setup.html#additional-settings
    DASHBOARD_ENABLE_FULL_EXPORT = True  # allow csv export on /explore

DATABASES["worker"] = DATABASES["default"].copy()
DATABASE_ROUTERS = [
    "hat.common.dbrouter.DbRouter",
]
# This database settings which duplicate the main db settings, will be used by the background task worker so that they
# can have a connexion outside of the transaction to report the progress on a Task. see Comments in services.py

# New django 3.2 settings to control which type of field is used by default for primary key
# Added to remove unecessary warning
# https://docs.djangoproject.com/en/4.0/releases/3.2/#customizing-type-of-auto-created-primary-keys
DEFAULT_AUTO_FIELD = "django.db.models.AutoField"


def is_superuser(u):
    return u.is_superuser


# Password validation

AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

# Internationalization

LANGUAGE_CODE = "en"

LANGUAGES = (
    ("fr", _("French")),
    ("en", _("English")),
)

LOCALE_PATHS = ["/var/app/current/hat/locale/", "/opt/app/hat/locale/", "hat/locale/"]

TIME_ZONE = "UTC"

USE_I18N = True


# We need a custom setting, because when USE_L10N is True, the locale-dictated
# `DATE_INPUT_FORMATS` has higher precedence and will be applied instead.
# https://docs.djangoproject.com/en/dev/ref/settings/#date-input-formats
API_DATE_INPUT_FORMATS = [
    "%d-%m-%Y",  # '25-10-2006'
    "%d/%m/%Y",  # '25/10/2006'
    "%Y-%m-%d",  # '2006-10-25'
    "%Y/%m/%d",  # '2006/10/25'
    "%m-%d-%Y",  # '10-25-2006'
    "%m/%d/%Y",  # '10/25/2006'
]

USE_TZ = True

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))

LOGIN_URL = "/login"
LOGIN_REDIRECT_URL = "/"

AUTH_CLASSES = [
    "rest_framework_simplejwt.authentication.JWTAuthentication",
    "iaso.api.auth.authentication.CsrfExemptSessionAuthentication",
]

# Needed for PowerBI, used for the Polio project, which only supports BasicAuth.
if "polio" in PLUGINS:
    AUTH_CLASSES.append(
        "rest_framework.authentication.BasicAuthentication",
    )

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": AUTH_CLASSES,
    "DEFAULT_PERMISSION_CLASSES": ("hat.api.authentication.UserAccessPermission",),
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.LimitOffsetPagination",
    "DEFAULT_FILTER_BACKENDS": ["django_filters.rest_framework.DjangoFilterBackend"],
    "PAGE_SIZE": None,
    "ORDERING_PARAM": "order",
    "DEFAULT_THROTTLE_RATES": {"anon": "200/day"},
    "DEFAULT_RENDERER_CLASSES": (
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
        "rest_framework_csv.renderers.CSVRenderer",
    ),
}

SIMPLE_JWT = {"ACCESS_TOKEN_LIFETIME": timedelta(days=3650), "REFRESH_TOKEN_LIFETIME": timedelta(days=3651)}

AWS_S3_REGION_NAME = os.getenv("AWS_S3_REGION_NAME", "eu-central-1")
AWS_ACCESS_KEY_ID = os.getenv("AWS_ACCESS_KEY_ID")
AWS_SECRET_ACCESS_KEY = os.getenv("AWS_SECRET_ACCESS_KEY")

MEDIA_URL_PREFIX = "/media/"
if USE_S3:
    # https://django-storages.readthedocs.io/en/latest/backends/amazon-S3.html
    AWS_S3_OBJECT_PARAMETERS = {"CacheControl": "max-age=86400"}
    AWS_IS_GZIPPED = True
    AWS_S3_FILE_OVERWRITE = False
    S3_USE_SIGV4 = True
    AWS_S3_SIGNATURE_VERSION = "s3v4"
    AWS_S3_HOST = "s3.%s.amazonaws.com" % AWS_S3_REGION_NAME
    AWS_DEFAULT_ACL = None
    S3_ENDPOINT_URL = os.environ.get("AWS_S3_ENDPOINT_URL", None)

    # s3 static settings
    if CDN_URL:
        # Only static files, not media files
        STATIC_URL = "//%s/static/" % (CDN_URL)
    else:
        STATIC_LOCATION = "iasostatics"
        STATICFILES_STORAGE = "iaso.storage.StaticStorage"
        STATIC_URL = "https://%s.s3.amazonaws.com/%s/" % (AWS_STORAGE_BUCKET_NAME, STATIC_LOCATION)

    MEDIA_URL = "https://%s.s3.amazonaws.com/" % AWS_STORAGE_BUCKET_NAME  # subdirectories will depend on field

    if S3_ENDPOINT_URL:
        AWS_S3_ENDPOINT_URL = S3_ENDPOINT_URL
        STATIC_LOCATION = "iasostatics"
        STATIC_URL = S3_ENDPOINT_URL + "/" + AWS_STORAGE_BUCKET_NAME + "/" + STATIC_LOCATION + "/"
        MEDIA_URL = S3_ENDPOINT_URL + "/" + AWS_STORAGE_BUCKET_NAME + "/"

        print("using s3 alternative", AWS_S3_ENDPOINT_URL)
        print(" STATIC_URL", STATIC_URL)
        print(" MEDIA_URL", MEDIA_URL)

    DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
else:
    SERVER_URL = os.environ.get("SERVER_URL", "")
    MEDIA_URL = SERVER_URL + MEDIA_URL_PREFIX
    STATIC_URL = "/static/"
    STATIC_ROOT = os.path.join(BASE_DIR, "static")
    MEDIA_ROOT = os.path.join(BASE_DIR, "media")

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "iaso/static"),
    os.path.join(BASE_DIR, "hat/assets/webpack"),
]

# Javascript/CSS Files:
WEBPACK_LOADER = {
    "DEFAULT": {
        "BUNDLE_DIR_NAME": "",  # used in prod
        "STATS_FILE": os.path.join(
            PROJECT_ROOT,
            "assets/webpack",
            (
                "webpack-stats.json"
                if (DEBUG and not os.environ.get("TEST_PROD", None) and not USE_S3)
                else "webpack-stats-prod.json"
            ),
        ),
    },
}

AUTH_PROFILE_MODULE = "hat.users.Profile"

try:
    from hat.__version__ import VERSION
except Exception as e:
    print("error importing hat.__version", e)
    VERSION = "undetected_version"


def get_env_as_float(variable_name: str, default_str: str) -> float:
    var_str: str = os.environ.get(variable_name, default_str)
    try:
        return float(var_str)
    except ValueError:
        raise Exception(f"Error wrong {variable_name} value {var_str}, should be float")


if SENTRY_URL:
    traces_sample_rate = get_env_as_float("SENTRY_TRACES_SAMPLE_RATE", "0.1")

    # from OpenHexa
    # Exclude /_health/ from sentry  as it fill the quota
    def sentry_tracer_sampler(sampling_context):
        transaction_context = sampling_context.get("transaction_context")
        if transaction_context is None:
            return 0

        op = transaction_context.get("op")

        if op == "http.server":
            path = sampling_context.get("wsgi_environ", {}).get("PATH_INFO")
            # Monitoring endpoints
            if path.startswith("/_health"):
                return 0

    ignore_logger("django.security.DisallowedHost")

    errors_sample_rate = get_env_as_float("SENTRY_ERRORS_SAMPLE_RATE", "1.0")

    httperror_errors_sample_rate = get_env_as_float("SENTRY_ERRORS_HTTPERROR_SAMPLE_RATE", "0.8")

    # Helps reducing sentry quota usage when bad request/connectivity issue with external api
    def sentry_error_sampler(_, hint):
        exception_sampler_values = {
            HTTPError: httperror_errors_sample_rate,
        }

        try:
            return exception_sampler_values[hint["exc_info"][0]]
        except (IndexError, KeyError, TypeError):
            return errors_sample_rate

    sentry_sdk.init(
        SENTRY_URL,
        traces_sample_rate=traces_sample_rate,
        traces_sampler=sentry_tracer_sampler,
        error_sampler=sentry_error_sampler,
        integrations=[DjangoIntegration()],
        send_default_pii=True,
        release=VERSION,
        ignore_errors=["django.security.DisallowedHost"],
    )

# Workers configuration
#
# Define if this environment is a worker (not in use)
IS_BACKGROUND_WORKER = bool(os.environ.get("WORKER", False))

# Define the backend to be used:
#   Needs to be one of: POSTGRES, SQS
#   Defaulting to SQS in production and Postgres in DEBUG
DEFAULT_BACKGROUND_BACKEND = "POSTGRES" if DEBUG else "SQS"
BACKGROUND_BACKEND = os.environ.get("BACKGROUND_TASK_SERVICE", DEFAULT_BACKGROUND_BACKEND)

if BACKGROUND_BACKEND == "POSTGRES":
    # Postgres backed background jobs
    BEANSTALK_WORKER = False
    BACKGROUND_TASK_SERVICE = "beanstalk_worker.services.PostgresTaskService"
elif BACKGROUND_BACKEND == "SQS":
    # SQS backed background jobs, SQS will send job payloads to `tasks/task`
    BEANSTALK_WORKER = IS_BACKGROUND_WORKER  # Used to expose extra URLs
    BACKGROUND_TASK_SERVICE = "beanstalk_worker.services.TaskService"
    BEANSTALK_SQS_URL = os.environ.get(
        "BEANSTALK_SQS_URL", "https://sqs.eu-central-1.amazonaws.com/198293380284/iaso-staging-queue"
    )
    BEANSTALK_SQS_REGION = os.environ.get("BEANSTALK_SQS_REGION", "eu-central-1")
else:
    raise Exception("BACKGROUND_TASK_SERVICE needs to one of: POSTGRES, SQS")

DISABLE_SSL_REDIRECT = bool(os.environ.get("DISABLE_SSL_REDIRECT", False))
SSL_ON = not (DEBUG or BEANSTALK_WORKER or DISABLE_SSL_REDIRECT)
if SSL_ON:
    SECURE_HSTS_SECONDS = 31_536_000  # 1 year
SECURE_SSL_REDIRECT = SSL_ON
# AWS Health check need to be able to access this endpoint directly to verify that the server is up
SECURE_REDIRECT_EXEMPT = [r"_health/$"]

# Email configuration

DEFAULT_FROM_EMAIL = os.environ.get("DEFAULT_FROM_EMAIL", "Iaso <no-reply@iaso.bluesquare.org>")
EMAIL_BACKEND = os.environ.get("EMAIL_BACKEND", "django.core.mail.backends.smtp.EmailBackend")
EMAIL_HOST = os.environ.get("EMAIL_HOST", "mail.smtpbucket.com")
EMAIL_HOST_USER = os.environ.get("EMAIL_HOST_USER", "")
EMAIL_HOST_PASSWORD = os.environ.get("EMAIL_HOST_PASSWORD", "")
EMAIL_PORT = os.environ.get("EMAIL_PORT", "8025")
EMAIL_USE_TLS = os.environ.get("EMAIL_TLS", "true") == "true"

# Application customizations
APP_TITLE = os.environ.get("APP_TITLE", "Iaso")
FAVICON_PATH = os.environ.get("FAVICON_PATH", "images/iaso-favicon.png")
LOGO_PATH = os.environ.get("LOGO_PATH", "images/logo.png")
THEME_PRIMARY_COLOR = os.environ.get("THEME_PRIMARY_COLOR", "#006699")
THEME_SECONDARY_COLOR = os.environ.get("THEME_SECONDARY_COLOR", "#0066CC")
THEME_PRIMARY_BACKGROUND_COLOR = os.environ.get("THEME_PRIMARY_BACKGROUND_COLOR", "#F5F5F5")
SHOW_NAME_WITH_LOGO = os.environ.get("SHOW_NAME_WITH_LOGO", "yes")

AUTHENTICATION_BACKENDS = [
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
]

SITE_ID = 1

ACCOUNT_EMAIL_VERIFICATION = "none"

CODE_CHALLENGE = generate_pkce()

SOCIALACCOUNT_PROVIDERS = {}

WFP_AUTH_CLIENT_ID = os.environ.get("WFP_AUTH_CLIENT_ID", False)
ACTIVATE_SOCIAL_ACCOUNT = WFP_AUTH_CLIENT_ID is not False  # for now, only WFP uses social_accounts
if WFP_AUTH_CLIENT_ID:
    # Activate WFP login
    # activate the wfp_auth plugin only if needed
    index = INSTALLED_APPS.index("allauth.socialaccount")
    INSTALLED_APPS.insert(index + 1, "plugins.wfp_auth")
    iaso_account = os.environ.get("WFP_AUTH_ACCOUNT", "")
    if not iaso_account:
        raise ImproperlyConfigured("need a WFP_AUTH_ACCOUNT to associate a tenant to the auth server")
    SOCIALACCOUNT_PROVIDERS["wfp"] = {
        "AUTH0_URL": "https://ciam.auth.wfp.org/oauth2",
        "APP": {
            "client_id": os.environ.get("WFP_AUTH_CLIENT_ID"),
            "secret": None,  # Secret is not accepted since we use PKCE
        },
        "OAUTH_PKCE_ENABLED": True,
        # To which tenant this is linked
        "IASO_ACCOUNT_NAME": iaso_account,
        "EMAIL_RECIPIENTS_NEW_ACCOUNT": os.environ.get("WFP_EMAIL_RECIPIENTS_NEW_ACCOUNT", "").split(","),
    }

CACHES = {
    "default": {
        "BACKEND": CACHE_BACKEND,
        "LOCATION": CACHE_LOCATION,
        "OPTIONS": {"MAX_ENTRIES": CACHE_MAX_ENTRIES},
    }
}

# sample celery configuration
CELERY_BROKER_URL = os.environ.get("CELERY_BROKER_URL", "redis://localhost:6379")
CELERY_RESULT_BACKEND = os.environ.get("CELERY_RESULT_BACKEND", "redis://localhost:6379")
CELERY_RESULT_SERIALIZER = "json"
CELERY_RESULT_EXTENDED = True

# Plugin config
print("Enabled plugins:", PLUGINS, end=" ")
for plugin_name in PLUGINS:
    try:
        plugin_settings = importlib.import_module(f"plugins.{plugin_name}.plugin_settings")

        if hasattr(plugin_settings, "INSTALLED_APPS"):
            INSTALLED_APPS.extend(plugin_settings.INSTALLED_APPS)

        if hasattr(plugin_settings, "CONSTANTS"):
            # Inject CONSTANTS dictionary into the Django settings
            for constant, value in plugin_settings.CONSTANTS.items():
                globals()[constant] = value

        if hasattr(plugin_settings, "TEMPLATES_DIRS"):
            TEMPLATES[0]["DIRS"].extend(plugin_settings.TEMPLATES_DIRS)

        if hasattr(plugin_settings, "STATICFILES_DIRS"):
            STATICFILES_DIRS.extend(plugin_settings.STATICFILES_DIRS)

        if hasattr(plugin_settings, "WEBPACK_LOADER"):
            WEBPACK_LOADER |= plugin_settings.WEBPACK_LOADER

    except ModuleNotFoundError:  # Use "simple" plugin system if no settings file found
        INSTALLED_APPS.append(f"plugins.{plugin_name}")


FILE_SERVER_URL = os.environ.get("FILE_SERVER_URL", "https://bram.ngrok.app")
